---layout: default---# History of C
## Early developments[edit]
The origin of C is closely tied to the development of theUnixoperating system, originally implemented inassembly languageon aPDP-7byDennis RitchieandKen Thompson, incorporating several ideas from colleagues.  Eventually, they decided to port the operating system to aPDP-11. The original PDP-11 version of Unix was also developed in assembly language.[8]
### B[edit]
Thompson wanted a programming language for developing utilities for the new platform. At first, he tried to write aFortrancompiler, but soon gave up the idea. Instead, he created a cut-down version of the recently developedsystems programming languagecalledBCPL. The official description of BCPL was not available at the time[14]and Thompson modified the syntax to be less wordy, and similar to a simplifiedALGOLknown as SMALGOL.[15]Thompson called the resultB.[8]He described B as "BCPL semantics with a lot of SMALGOL syntax".[15]Like BCPL, B had abootstrappingcompiler to facilitate porting to new machines.[15]However, few utilities were ultimately written in B because it was too slow, and could not take advantage of PDP-11 features such asbyteaddressability.
### New B and first C release[edit]
In 1971, Ritchie  started to improve B, to utilise the features of the more-powerful PDP-11.  A significant addition was a character data type.  He called thisNew B(NB).[15]Thompson started to use NB to write theUnixkernel, and his requirements shaped the direction of the language development.[15][16]Through to 1972, richer types were added to the NB language: NB had arrays ofintandchar. Pointers, the ability to generate pointers to other types, arrays of all types, and types to be returned from functions were all also added. Arrays within expressions became pointers. A new compiler was written, and the language was renamed C.[8]
The C compiler and some utilities made with it were included inVersion 2 Unix, which is also known asResearch Unix.[17]
### Structures and the Unix kernel re-write[edit]
AtVersion 4 Unix, released in November 1973, theUnixkernelwas extensively re-implemented in C.[8]By this time, the C language had acquired some powerful features such asstructtypes.
Thepreprocessorwas introduced around 1973 at the urging ofAlan Snyderand also in recognition of the usefulness of the file-inclusion mechanisms available in BCPL andPL/I. Its original version provided only included files and simple string replacements:#includeand#defineof parameterless macros. Soon after that, it was extended, mostly byMike Leskand then by John Reiser, to incorporate macros with arguments andconditional compilation.[8]
Unix was one of the first operating system kernels implemented in a language other thanassembly. Earlier instances include theMulticssystem (which was written inPL/I) andMaster Control Program(MCP) for theBurroughs B5000(which was written inALGOL) in 1961. In around  1977, Ritchie andStephen C. Johnsonmade further changes to the language to facilitateportabilityof the Unix operating system.  Johnson'sPortable C Compilerserved as the basis for several implementations of C on new platforms.[16]
## K&R C[edit]
In 1978,Brian KernighanandDennis Ritchiepublished the first edition ofThe C Programming Language.[18]Known asK&Rfrom the initials of its authors, the book served for many years as an informalspecificationof the language. The version of C that it describes is commonly referred to as "K&R C". As this was released in 1978, it is now also referred to asC78.[19]The second edition of the book[20]covers the laterANSI Cstandard, described below.
K&Rintroduced several language features:
Even after the publication of the 1989 ANSI standard, for many years K&R C was still considered the "lowest common denominator" to which C programmers restricted themselves when maximum portability was desired, since many older compilers were still in use, and because carefully written K&R C code can be legal Standard C as well.
In early versions of C, only functions that return types other thanintmust be declared if used before the function definition; functions used without prior declaration were presumed to return typeint.
For example:
Theinttype specifiers which are commented out could be omitted in K&R C, but are required in later standards.
Since K&R function declarations did not include any information about function arguments, function parametertype checkswere not performed, although some compilers would issue a warning message if a local function was called with the wrong number of arguments, or if different calls to an external function used different numbers or types of arguments.  Separate tools such as Unix'slintutility were developed that (among other things) could check for consistency of function use across multiple source files.
In the years following the publication of K&R C, several features were added to the language, supported by compilers from AT&T (in particularPCC[21]) and some other vendors. These included:
The large number of extensions and lack of agreement on astandard library, together with the language popularity and the fact that not even the Unix compilers precisely implemented the K&R specification, led to the necessity of standardization.[citation needed]
## ANSI C and ISO C[edit]
During the late 1970s and 1980s, versions of C were implemented for a wide variety ofmainframe computers,minicomputers, andmicrocomputers, including theIBM PC, as its popularity began to increase significantly.
In 1983, theAmerican National Standards Institute(ANSI) formed a committee, X3J11, to establish a standard specification of C. X3J11 based the C standard on the Unix implementation; however, the non-portable portion of the Unix C library was handed off to theIEEEworking group1003 to become the basis for the 1988POSIXstandard. In 1989, the C standard was ratified as ANSI X3.159-1989 "Programming Language C".  This version of the language is often referred to asANSI C, Standard C, or sometimes C89.
In 1990, the ANSI C standard (with formatting changes) was adopted by theInternational Organization for Standardization(ISO) as ISO/IEC 9899:1990, which is sometimes called C90. Therefore, the terms "C89" and "C90" refer to the same programming language.
ANSI, like other national standards bodies, no longer develops the C standard independently, but defers to the international C standard, maintained by the working groupISO/IEC JTC1/SC22/WG14.  National adoption of an update to the international standard typically occurs within a year of ISO publication.
One of the aims of the C standardization process was to produce asupersetof K&R C, incorporating many of the subsequently introduced unofficial features. The standards committee also included several additional features such asfunction prototypes(borrowed from C++),voidpointers, support for internationalcharacter setsandlocales, and preprocessor enhancements. Although thesyntaxfor parameter declarations was augmented to include the style used in C++, the K&R interface continued to be permitted, for compatibility with existing source code.
C89 is supported by current C compilers, and most modern C code is based on it. Any program written only in Standard C and without any hardware-dependent assumptions will run correctly on anyplatformwith a conforming C implementation, within its resource limits.  Without such precautions, programs may compile only on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries, such asGUIlibraries, or to a reliance on compiler- or platform-specific attributes such as the exact size of data types and byteendianness.
In cases where code must be compilable by either standard-conforming or K&R C-based compilers, the__STDC__macro can be used to split the code into Standard and K&R sections to prevent the use on a K&R C-based compiler of features available only in Standard C.
After the ANSI/ISO standardization process, the C language specification remained relatively static for several years. In 1995, Normative Amendment 1 to the 1990 C standard (ISO/IEC 9899/AMD1:1995, known informally as C95) was published, to correct some details and to add more extensive support for international character sets.[22]
## C99[edit]
The C standard was further revised in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which is commonly referred to as "C99". It has since been amended three times by Technical Corrigenda.[23]
C99 introduced several new features, includinginline functions, several newdata types(includinglong long intand acomplextype to representcomplex numbers),variable-length arraysandflexible array members, improved support forIEEE 754floating point, support forvariadic macros(macros of variablearity), and support for one-line comments beginning with//, as in BCPL or C++. Many of these had already been implemented as extensions in several C compilers.
C99 is for the most part backward compatible with C90, but is stricter in some ways; in particular, a declaration that lacks a type specifier no longer hasintimplicitly assumed. A standard macro__STDC_VERSION__is defined with value199901Lto indicate that C99 support is available.GCC,Solaris Studio, and other C compilers now[when?]support many or all of the new features of C99. The C compiler inMicrosoft Visual C++, however, implements the C89 standard and those parts of C99 that are required for compatibility withC++11.[24][needs update]
In addition, the C99 standard requires support foridentifiersusingUnicodein the form of escaped characters (e.g.\u0040or\U0001f431) and suggests support for raw Unicode names.
## C11[edit]
In 2007, work began on another revision of the C standard, informally called "C1X" until its official publication of ISO/IEC 9899:2011 on 2011-12-08. The C standards committee adopted guidelines to limit the adoption of new features that had not been tested by existing implementations.
The C11 standard adds numerous new features to C and the library, including type generic macros, anonymous structures, improved Unicode support, atomic operations, multi-threading, and bounds-checked functions.  It also makes some portions of the existing C99 library optional, and improves compatibility with C++. The standard macro__STDC_VERSION__is defined as201112Lto indicate that C11 support is available.
## C17[edit]
Published in June 2018 as ISO/IEC 9899:2018, C17 is the current standard for the C programming language. It introduces no new language features, only technical corrections, and clarifications to defects in C11. The standard macro__STDC_VERSION__is defined as201710Lto indicate that C17 support is available.
## C23[edit]
C23 is the informal name for the next (after C17) major C language standard revision. It was informally known as "C2X" through most of its development. C23 is expected to be published in early 2024 as ISO/IEC 9899:2024.[25]The standard macro__STDC_VERSION__is defined as202311Lto indicate that C23 support is available.
## C2Y[edit]
C2Y is an informal name for the next (after C23) major C language standard revision that is hoped to be released later in the2020sdecade, per the two in "C2Y". An early working draft of C2Y was released in February 2024 as N3220 by the working groupISO/IEC JTC1/SC22/WG14.[26]
## Embedded C[edit]
Historically, embedded C programming requires nonstandard extensions to the C language in order to support exotic features such asfixed-point arithmetic, multiple distinct memory banks, and basic I/O operations.
In 2008, the C Standards Committee published atechnical reportextending the C language[27]to address these issues by providing a common standard for all implementations to adhere to. It includes a number of features not available in normal C, such asfixed-point arithmetic, named address spaces, and basic I/O hardware addressing.
